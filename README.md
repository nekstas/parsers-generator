# Генератор SLR(1)-парсеров на C++

Эта программа позволяет позволяет генерировать SLR(1)-парсеры на C++ по заданной грамматике, описанной в специальном
формате.

## Зависимости

- Компилятор C++ с поддержкой стандарта C++23.
- Система сборки CMake версии 3.29 или выше
- [re2c](https://github.com/skvadrik/re2c) для генерации лексера для токенизатора (опционально)

Также рекомендуется использовать clang-format для форматирования генерируемого парсером кода.

## Использование

Для использования генератора парсеров его нужно скомпилировать с помощью CMake, цель `parsers_generator`.

Затем можно использовать генератор следующим образом:

```
parsers_generator <action> <grammar_file> <output_path>
```

Аргументы:

- `<action>` --- это действие, которое нужно выполнить генератору. Может быть `create` для создания парсера с нуля или
  `update`, если требуется обновить код уже существующего парсера.
- `<grammar_file>` --- путь к файлу с грамматикой языка, записанной в специальном
  формате (формат описан ниже).
- `<output_path>` --- путь к директории, в которую необходимо поместить все необходимые файлы сгенерированного парсера (
  если директория не существует, то она будет создана, но только если все остальные части пути уже существуют).

### Формат файла с грамматикой

Формат основан на BNF (форме Бэкуса-Наура), но также задаёт возвращаемые типы для каждого нетерминала, какие символы в
каждой продукции используются и какой обработчик должен её обрабатывать.

```
# Комментарий. С помощью квадратных скобок обозначается начало определения нетерминала

[RuleName]  # Все имена начинаются с латинской буквы, а затем произвольное число латинских букв или цифр (возможно 0).
Token <NonTerminal> -> HandlerName1
# С помощью $ обозначаются символы, которые нужно передать в обработчик
$Token1 Token2 <NonTerminal1> $<NonTerminal2> Token3 -> HandlerName2
<> -> HandlerName3  # epsilon-продукция

# С помощью @ обозначается главное правило
# Можно также указать возвращаемый тип. Если он не указан, то он совпадает с названием нетерминала
# Возвращаемый тип должен быть классом, наследуемым от ast::Node

@[MainRule:ReturnType] # В одном файле описывается только одна грамматика
$<RuleName> $Number -> Production

# Нельзя определять неиспользуемые правила или использовать несуществующие. Порядок правил неважен.
@[Sequence] # Грамматика правильных скобочных последовательностей
<> -> EmptySequence
Open $<Sequence> Close $<Sequence> -> NotEmptySequence
```

Описание каждого нетерминала начинается с пары квадратных скобок, внутри которых указывается название нетерминала и,
опционально, через двоеточие может указываться тип возвращаемого значения продукций для данного нетерминала (если он не
указан, то он равен самому названию терминала). Все названия должны начинаться с латинской буквы в произвольном
регистре, а затем могут содержать латинские буквы в любом регистре и цифры. Использовать символы `-` или `_` для
названий нельзя.

Далее указываются одна или несколько продукций. Продукция состоит из одного или нескольких символов. Для терминалов
стоит использовать просто их название. Нетерминалы стоит заключать в треугольные скобки, например, `<expression>`. Если
какой-то терминал нужно передать в обработчик, то перед ним ставится знак доллара (`$`). После последовательности
символов следует стрелка `(->)` и название обработчика, которому будут переданы выбранные символы (для нетерминалов их
тип определяется в описании грамматики, терминалы передаюстя с использованием класса `Token`, который содержит позицию
терминала в файле, его значение, а также тип).

Для пустых продукций можно использовать синтаксис `<> -> HandlerName`. Для определения главного правила перед его
началом стоит написать символ `@`. Также можно использовать однострочные комментарии, которые начинаются с символа
решётки (`#`) и заканчиваются с началом новой строки.

Обратите внимание, язык нечувствителен к пробельным символам (пробелы и табы), а также к переносам строк. Таким образом,
Вы можете записать всю вашу грамматику в одну строку. Однако не стоит этим злоупотреблять и рекомендуется писать каждую
продукцию и начало нетерминала на новой строке, а различные нетерминалы разделять пустой строкой.

Вы можете указывать все правила в любом порядке. Нельзя указывать неиспользуемые нетерминалы в продукциях, а также
использовать несуществующие нетерминалы. Также нельзя использовать больше одного заголовка (`[Name]`) для одинаковых
названий нетерминалов. Нельзя использовать одинаковое имя для обработчиков, отвечающих за разные продукции.

Записанная грамматика должна распознаваться SLR(1)-парсером, иначе вы получите сообщение об ошибке.

Ознакомиться с примерами записи грамматик можно в директории [examples/](examples/) данного проекта.

Например, грамматику для правильных скобочных последовательностей можно записать следующим образом:

```
@[Sequence] # Грамматика правильных скобочных последовательностей
<> -> EmptySequence
Open $<Sequence> Close $<Sequence> -> NotEmptySequence
```

### Результат работы генератора

В результате работы генератора парсеров создаются различные файлы, необходимые для работы созданного парсера. Файлы
делятся на три директории: `lib`, `data` и `usr`.

- Файлы в директории `lib` представляют библиотечные файлы, одинаковые
  для всех парсеров, содержащие полезные классы. Их не стоит менять.
- Файлы в директории `data` представляют два `enum` с типами возможных токенов (заданных неявно в файле описания
  грамматики), и типами нетерминалов (их названия), а также таблицы для работы LR(1)-парсера, описание грамматики и
  интерфейс для класса с обработчиками заданных продукций (файл `ast_builder.h`). Эти файлы также не стоит менять
  вручную.
- Файлы в директории `usr` создаются пользователем и необходимы для работы парсера. Некоторые файлы содержат небольшой
  шаблон того, что в них должно находиться.
    - Файл `ast_nodes.h` должен содержать определения всех классов, которые указаны в файле с описанием грамматики в
      качестве возвращаемых типов некоторых нетерминалов.
    - Файл `lexer.cpp` должен содержать реализацию лексера, который принимает указатели на текущую позицию в строке и на
      конец строки и возвращает тип токена, если может его распознать, `TokenType::Skip`, если токен необходимо
      пропустить или `TokenType::Unknown`, если лексер не может распознать текущий токен. При этом после распознавания
      токена `str_ptr` (указатель на текущую позицию в строке) должен указывать на символ, следующий за последним
      символом распознанного токена.
    - Для генерации `lexer.cpp` рекомендуется использовать библиотеку `re2c`, и с помощью неё написать распознавание
      необходимых токенов. В файле `lexer.re` содержится необходимый шаблон. Но Вы также можете писать лексер вручную
      или с использованием других инструментов.
    - Также вам необходимо создать файл с реализацией интерфейса `pg::AstBuilder`, в котором необходимо определить
      действия для каждой указанной в файле с грамматикой продукции.

Файлы в директориях `lib` и `usr` изменяются только при использовании `action` равного `create`. Файлы в директории
`data` обновляются как при `create`, так и при `update`.

Затем вы можете использовать сгенерированный парсер в своём коде следующим образом:

```cpp
YourAstBuilder builder;
pg::LrParser::Create().Parse(code, builder);
```

При успешном распознавании грамматики вызывается метод `Accept` у вашего `builder` с объектом, возвращённым последней
применённой продукцией главного правила. Вы можете получить результат, реализовав собственный метод, например
`GetResult`, а результат сохранять в методе `Accept`.

В случае, если лексеру не получилось распознать какой-либо токен, бросается исключение `TokenizerError`, а если парсер
обнаружил символ, который не ожидал, то бросается исключение `ParserError`. Вы можете красиво вывести полученную ошибку
используя метод `pg::ErrorPrinter::Print`.

Для более детального понимания устройства сгенерированного парсера вы можете изучить парсер, расположенный в
директории [core/grammar_parser/](core/grammar_parser/), так как парсер грамматик в указанном формате создан с помощью
данного генератора.
